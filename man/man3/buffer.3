.TH BUFFER 3 2012-09-03 "IB 321" "Systemnahes Programmieren"
.SH NAME
makebuf, initbuf, bopen, bclose, termbuf, freebuf, flushbuf, bgetchar,
bungetchar, fillbuf
\- buffered I/O
.SH SYNOPSIS
.B #include <buffer.h>
.PP
.BI "Buffer *makebuf(size_t " size );
.PP
.BI "int initbuf(Buffer *" buf ", int " fd ", int " mode );
.PP
.BI "Buffer *bopen(char *" name ", int " mode );
.PP
.BI "int bclose(Buffer *" buf );
.PP
.BI "int termbuf(Buffer *" buf );
.PP
.BI "void freebuf(Buffer *" buf );
.PP
.BI "int bflush(Buffer *" buf );
.PP
.BI "int bgetchar(Buffer *" buf );
.PP
.BI "int bungetchar(Buffer *" buf );
.PP
.BI "int fillbuf(Buffer *" buf );
.PP
.BI "int bputchar(Buffer *" buf ", uchar " c  );
.PP
.BI "int bprintf(Buffer *" buf ", uchar *" fmt ", " ... );
.PP
.BI "int vbprintf(Buffer *" buf ", uchar *" fmt ", va_list " args );
.PP
.SH DESCRIPTION
These routines implement buffered I/O. Writebuffers are flushed at
.BI exit (3)
\&. Up to 8 Writebuffers per process are possible.
.PP
.BI makebuf
uses
.BR malloc (3)
to allocate a
.I Buffer
structure and then
.BR posix_memalign (2)
to acquire an aligned buffer suitable for I/O with
.B O_DIRECT
\&. It returns
.I NULL
on failure, while
.I errno
is set.
.PP
.BI initbuf
initializes
.I buf
with
.I file
\&, which must already be opened with
.B O_RDONLY
or
.B O_WRONLY
\&. On success,
.I 0
is returned,
.I EOF
otherwise and
.I errno
is set.
.PP
.B bopen
opens the file specified by
.I name
\&, then calls
.BI makebuf
and
.BI initbuf
to allocate a buffer and associate the file with it.
A pointer to the buffer is returned, or
.I NULL
and errno is set if an error occured.
.PP
.BI termbuf
flushes
.I buf
and disassociates the file from it.
The file is not closed.
It returns the result from
.BI bflush
\&.
.PP
.BI freebuf
frees the memory allocated for the buffer.
.PP
.BI bflush
flushes the buffer.
On success,
.I 0
is returned,
.I EOF
otherwise and
.I errno
is set.
.PP
.BI bclose
flushes the buffer and closes the file associated with
.I buf
\&, then calls
.BI freebuf
\&.
.PP
.BI bgetchar
returns the next character from
.I buf
or
.I EOF
if at end of file or an error occured.
In the latter case,
.I errno
is set.
.PP
.BI bungetchar
pushes the last last character back.
This works up to 4 times.
If the character cannot be pushed back,
.I EOF
is returned, otherwise 0.
.PP
.BI fillbuf
reads another chunk from the associated file.
If an error occurs,
.I EOF
is returned, 0 otherwise, and
.I errno
is set appropriately.
If the end of file is reached,
.I errno
is not set.
.PP
.BI bputchar
puts
.I c
into
.I buf
\&.
.PP
.BI bprintf
and
.BI vbprintf
act like
.BI printf (3)
and
.BI vprintf (3)
respectively.
.SH SEE ALSO
.BR malloc (3),
.BR posix_memalign (3),
.BR open (2),
.BR close (2),
.BR free (3)
.SH BUGS
File opening is currently only possible with
.B O_RDONLY
and
.B O_WRONLY
without any flags.
.PP
.BI bprintf
and
.BI bvprintf
produce holes in files.


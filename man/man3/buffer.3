.TH BUFFER 3 2012-09-03 "IB 321" "Systemnahes Programmieren"
.SH NAME
makebuf, initbuf, bopen, bclose, termbuf, freebuf, flushbuf, bgetchar,
bungetchar, fillbuf
\- buffered I/O
.SH SYNOPSIS
.B #include <buffer.h>
.PP
.BI "Buffer *makebuf(size_t " size );
.PP
.BI "int initbuf(Buffer *" buf ", int " fd ", int " mode );
.PP
.BI "Buffer *bopen(char *" name ", int " mode );
.PP
.BI "int bclose(Buffer *" buf );
.PP
.BI "int termbuf(Buffer *" buf );
.PP
.BI "void freebuf(Buffer *" buf );
.PP
.BI "int bflush(Buffer *" buf );
.PP
.BI "int bgetchar(Buffer *" buf );
.PP
.BI "int bungetchar(Buffer *" buf );
.PP
.BI "int fillbuf(Buffer *" buf);
.PP
.SH DESCRIPTION
These routines implement buffered I/O.
.PP
.BI makebuf
uses
.BR malloc (3)
to allocate a
.I Buffer
structure and then
.BR posix_memalign (2)
to acquire an aligned buffer suitable for I/O with
.B O_DIRECT
\&. It returns
.I NULL
on failure, while
.I errno
is set.
.PP
.BI initbuf
initializes
.I buf
with
.I file
\&, which must already be opened with
.B O_RDONLY
or
.B O_WRONLY
\&. On success,
.I 0
is returned,
.I EOF
otherwise and
.I errno
is set.
.PP
.B bopen
opens the file specified by
.I name
\&, then calls
.BI makebuf
and
.BI initbuf
to allocate a buffer and associate the file with it.
A pointer to the buffer is returned, or
.I NULL
and errno is set if an error occured.
.PP
.BI termbuf
flushes
.I buf
and disassociates the file from it.
The file is not closed.
It returns the result from
.BI bflush
\&.
.PP
.BI freebuf
frees the memory allocated for the buffer.
.PP
.BI bflush
flushes the buffer.
.PP
.BI bclose
flushes the buffer and closes the file associated with
.I buf
\&, then calls
.BI freebuf
\&.
.PP
.BI bgetchar
returns the next character from
.I buf
or
.I EOF
if at end of file or an error occured.
In the latter case,
.I errno
is set.
.PP
.BI bungetchar
pushes the last last character back.
This works up to 4 times.
If the character cannot be pushed back,
.I EOF
is returned, otherwise 0.
.PP
.BI fillbuf
reads another chunk from the associated file.
If an error occurs,
.I EOF
is returned, 0 otherwise, and
.I errno
is set appropriately.
If the end of file is reached,
.I errno
is not set.
.PP
.SH SEE ALSO
.BR malloc (3),
.BR posix_memalign (3),
.BR open (2),
.BR close (2),
.BR free (3)
.SH BUGS
File opening is currently only possible with
.B O_RDONLY
and
.B O_WRONLY
without any flags.

